## chapter 25 테스트 주도 개발 패턴

### 1. 테스트 (동사와 명사)

- 테스트 하는 동작과 테스트의 존재는 다른 의미이다 => 자동화된 테스트(명사)
- 스트레스 - 테스트 실행 의 상관관계 (positive feedback loop)

### 2. 격리된 테스트

- 작은 스케일, 독립된 테스트, 커플링은 지양
- 테스트의 결과는 응집도는 높고, 결합도는 낮은 객체의 모음

### 3. 테스트 목록

- 메모하라!
- 테스트의 목록 뿐 아니라 리팩토링 목록 역시 필요
- 테스트 전부를 구현하게 되면 초록 막대를 보는 시간까지의 힘듦이 존재한다 => 사중삼 법칙
- "제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈하는 것보다 더 중요하다" (p210)

### 4. 테스트 우선

### 5. 단언 우선

- 완료된 시스템의 모습, 기능완료시 통과될 테스트, 완료될 때 통과해야 할 단어 => 단언이 우선되면 목표가 명확해진다.

### 6. 테스트 데이터

- 테스트를 읽을 때 쉽고 따라하기 좋을 만한 데이터를 사용!
- 여러 의미를 담는 동일한 상수는 사용하지 말 것!

### 7. 명백한 데이터

- 데이터의 의도를 드러낼 수 있는 값을 사용하라! => 미래의 누군가가 의도를 파악할 수 있도록!

## chapter 26 빨간 막대 패턴

### 1. 한 단계 테스트

- 뻔하지 않지만 구현할 수 있는 확신이 있는 테스트부터
- "아는 것에서 모르는 것으로"

### 2. 시작 테스트

- 오퍼레이션이 무능한 경우부터 테스트
- 뭔가를 가르쳐 줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라!

### 3. 설명 테스트

- 테스트를 설명의 도구로 사용하라!

### 4. 학습 테스트

- 새로운 도구를 사용할 때 테스트를 작성하는 것이 러닝커브를 줄여줄 수 있다.

### 5. 또 다른 테스트

- 번뜩 생각나는 새로운 아이디어를 지키는 방법 => 리스트에 적어놓는 습관

### 6. 회귀 테스트

- 장애에 대한 테스트, 장애를 수정했다고 알 수 있는 테스트를 작성하라
- 회귀 테스트는 애초에 작성되어야 할 예외 테스트의 일종이다

### 7. 휴식

- 샤워 방법론
- 피로와 판단력
- 리프레쉬 할 수 있는 환경을 만들어라 (시간, 하루, 주, 연 단위)

### 8. 다시하기

- 다시 하는 것을 두려워하고, 아까워하지 마라!

### 9. 싸구려 책상, 좋은 의자

## chapter 27 테스팅 패턴

### 1. 자식 테스트

- 큰 테스트 케이스의 경우 => 테스트가 깨지는 작은 케이스부터 테스트하라!
- 큰 테스트를 작성한 후 개선사항에 대해 회고하라

### 2. 모의 객체

- 마치 데이터베이스처럼 행동하지만 메모리에만 존재하는 개체를 사용하라!
- 가독성이라는 장점
- 싱글톤이라고 하더라도 전역 변수를 사용하는 것은 테스트의 커플링을 발생시킨다

### 3. 셀프셔트

- 객체의 대화 상대를 테스트 케이스로 설정하라
- 인터페이스 추출 vs 블랙 박스 테스트

### 4. 로그 문자열

- 테스트마다 로그 문자열을 반환하면 호출 순서에 대해 파악할 수 있다

### 5. 크래시 테스트 더미

- 예외를 발생시키기만 하는 특수한 객체를 만들어서 호출

### 6. 깨진 테스트

- 혼자 프로그래밍을 할 경우 마지막 테스트가 꺠진 상태로 마쳐라 => 이후 이전의 테스트들에 대해 상기할 수 있는 여건을 마련해준다.

### 7. 깨끗한 체크인

- 팀 프로그래밍의 경우 반드시 모든 테스트가 성공한 상태로 마쳐야 한다

## chapter 28 초록 막대 패턴

### 1. 가짜로 구현하기

- stub 과 상수의 사용 => 이후 실제 메서드와 변수로 변형
- 이러하 접근이 때로는 새로운 아이디어를 주기도 한다
- 심리학적 효과와 고민의 범위 조절

### 2. 삼각측량

- 추상화는 예시가 두 개 이상일 때!

### 3. 명백한 구현

- 명확하게 구현할 수 있는 것들은 구현하라!
- 제대로 동작 => 깨끗한 코드

### 4. 하나에서 여럿으로

- 객체 컬렉션이 필요할 경우 => 컬렉션 없이 -> 컬렉션 사용

## chapter 30 디자인 패턴

- 우리가 만나는 문제의 대부분은 사용하는 도구에서 비롯되는 것들
- 디자인 패턴은 문제들을 해결하는 좋은 예
- 디자인 패턴의 단점 : 문제해결의 다양성을 억압
- TDD와의 차이는 리팩토링이 설계에 포함되어 있지 않다는 점

### 1. 커맨드

- 객체와 메서드를 분리하기 위해 메서드 호출 자체를 위한 객체를 만드는 방법
- 특정한 경우나 시점에만 필요한, 지속될 필요성이 없는 메서드를 분리시키기 위해 사용하는 것 같음
- "복잡한 형태의 계산 작업에 대한 호출" 이 필요할 떄

### 2. 값 객체

- 공유되어야 하지만, 동일성이 중요하지 않은 객체를 설계할 때 (동등성과 동일성은 다르다)
- 별칭 문제 => 객체에 대한 복사본 제공 || 옵저버 패턴
- 일종의 생성자 패턴을 얘기하는 것 같다

### 3. 널 객체

- 널을 위한 객체를 만들어 검사의 가독성을 높여라!

### 4. 템플릿 메서드

- 작업 순서가 동일하고, 작업의 요소가 조금 다를 때 템플릿 메서드를 상위 클래스에 생성해 동작할 수 있다

### 5. 플러거블 객체

- 중복된 조건문을 제거하고자 사용하는 패턴
- 초기에 조건문에 의해 결정되는 객체를 만들어 이후 실행되는 메소드에 모두 적용하는 방식
- 플러거블한 상태에 따라 객체를 전달하여 중복된 조건문을 제거

### 6. 플러거블 셀렉터

- 메서드를 동적으로 호출하기 위해 사용하는 패턴
- 메서드에서 현재 불러오고자 하는 메서드를 불러오는 동작을 만듦(switch 문을 제거 및 새로운 메서드의 불필요한 생성 방지)

### 7. 팩토리 메서드

- 새객체를 만들 때 유연성을 원하는 경우 일반 메서드에서 객체를 생성할 수 있도록 하는 방식
- 생성자 new 키워드 사용 없이 객체를 만들고자 할 떄 사용

### 8. 사칭 사기꾼

- 기존의 코드에서 새로운 변이를 도입할 떄 사용된다
- 리팩토링 중 널 객체, 컴포지트와 같은 모습으로 나타난다

### 9. 컴포지트

- 객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현

### 10. 수집 매개 변수

### 11. 싱글톤

- don't do that!

## chapter 31 리팩토링

- 리팩토링은 어떤 상황에서도 프로그램의 의미론을 변경해서는 안된다.
- '관측상의 동치성'

### 1. 차이점 일치시키기

- 두 코드를 합치기 위해서는 "단계적으로" 두 코드를 닮아가게 수정한다.
- 반복문, 조건문, 클래스 단위
- 하위 클래스 -> 상위클래스

### 2. 변화 격리하기

- 객체나 메서드의 일부를 변경하기 위해 해당 부분을 격리해야 한다
- 메서드 추출하기, 객체 추출하기, 메서드 객체 등이 있다

### 3. 데이터 이주시키기

- 데이터의 이주를 위해서 데이터를 중복시킨 후 단계적으로 삭제
- "하나에서 여럿으로"
- "단계적으로" 를 강조한 방법

### 4. 메서드 추출하기

- 하나의 메서드를 가독성 있게 만들기 위해 해당 메서드를 별도의 메서드로 조합한다.

### 5. 메서드 인라인

- 제어 흐름이 꼬여있거나 산재할 겨우 메서드를 호출하는 부분을 메서드의 본문으로 교체한다.

### 6. 인터페이스 추출하기

- 구현된 클래스와 비슷한 성질의 클래스를 구현할 경우 인터페이스를 추출한다.

### 7. 메서드 옮기기

### 8. 메서드 객체

- 매개변수와 지역변수가 많이 사용되는 메서드는 객체로 만든다

### 9. 매개 변수 추가

### 10. 메서드 매개 변수를 생성자 매개 변수로 바꾸기
